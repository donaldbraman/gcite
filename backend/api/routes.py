"""
API route handlers for gCite backend.
"""

from fastapi import APIRouter, HTTPException, Depends
import logging
import time

from .models import SearchRequest, SearchResponse, Chunk, Source
from services.cite_assist import CiteAssistClient, get_cite_assist_client

router = APIRouter()
logger = logging.getLogger(__name__)


@router.post("/search", response_model=SearchResponse)
async def search_citations(
    request: SearchRequest,
    cite_assist: CiteAssistClient = Depends(get_cite_assist_client)
):
    """
    Search for relevant citations.

    Process (Phase 1 - Basic):
    1. Semantic search via cite-assist
    2. Format results (no AI agents yet)

    Phase 2 will add:
    - AI filtering for relevance
    - AI ranking by importance
    - AI formatting for output
    """
    start_time = time.time()

    try:
        # Step 1: Semantic search via cite-assist
        logger.info(f"Searching for: {request.query}")
        raw_results = await cite_assist.search(
            query=request.query,
            limit=request.max_results
        )

        if not raw_results:
            return SearchResponse(
                query=request.query,
                results_count=0,
                chunks=[],
                formatted_output="No results found. Try refining your query.",
                processing_time_ms=int((time.time() - start_time) * 1000)
            )

        # Step 2: Convert to Chunk objects
        chunks = []
        for idx, result in enumerate(raw_results[:request.max_results]):
            # Parse cite-assist result format
            chunk = Chunk(
                id=result.get("chunk_id", f"chunk_{idx}"),
                text=result.get("text", ""),
                source=Source(
                    title=result.get("metadata", {}).get("title", "Unknown"),
                    authors=result.get("metadata", {}).get("authors", []),
                    year=result.get("metadata", {}).get("year", 0),
                    citation=result.get("metadata", {}).get("citation", ""),
                    item_key=result.get("source_key")
                ),
                relevance_score=result.get("score", 0.0),
                agent_filtered=False,
                agent_rank=idx + 1
            )
            chunks.append(chunk)

        # Step 3: Basic formatting (Phase 2 will use AI)
        formatted_output = _format_basic(chunks, request.citation_style)

        processing_time = int((time.time() - start_time) * 1000)

        return SearchResponse(
            query=request.query,
            results_count=len(chunks),
            chunks=chunks,
            formatted_output=formatted_output,
            processing_time_ms=processing_time
        )

    except Exception as e:
        logger.error(f"Search failed: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Search failed: {str(e)}"
        )


def _format_basic(chunks: list[Chunk], style: str) -> str:
    """
    Basic formatting without AI (Phase 1).
    Phase 2 will replace this with AI-powered formatting.
    """
    if not chunks:
        return "No citations found."

    lines = [
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        f"ğŸ“š CITATION RESULTS ({len(chunks)} found)",
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        ""
    ]

    for chunk in chunks:
        lines.extend([
            f"[{chunk.agent_rank}] {chunk.source.title}",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            f"Relevance: {chunk.relevance_score:.2f}",
            "",
            f'"{chunk.text}"',
            "",
            f"Citation: {chunk.source.citation}",
            "",
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
            ""
        ])

    lines.extend([
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        "Generated by gCite â€¢ cite-assist semantic search",
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    ])

    return "\n".join(lines)
